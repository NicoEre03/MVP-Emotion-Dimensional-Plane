<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotion Dimensional Plane - Heatmap Viewer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* General styling for the page */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 1 / 1;
            margin: 20px auto;
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
        }

        #chart {
            width: calc(100% - 40px);
            height: calc(100% - 40px);
            margin: 20px;
            cursor: default;
        }

        .axis-label {
            position: absolute;
            font-weight: 600;
            color: #555;
            font-size: 14px;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
        }

        .axis-label.x-positive {
            bottom: 15px;
            right: 40px;
        }

        .axis-label.x-negative {
            bottom: 15px;
            left: 40px;
        }

        .axis-label.y-positive {
            left: 5px;
            top: 15px;
        }

        .axis-label.y-negative {
            left: 5px;
            bottom: 15px;
        }

        .info-panel {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        button.secondary {
            background: #a0aec0;
        }
        button.secondary:hover {
            background: #718096;
        }

        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff6b6b;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease, top 0.3s ease;
            pointer-events: none;
        }

        #message-box.show {
            opacity: 1;
            top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Heatmap Viewer</h1>
        <p class="subtitle" id="subtitle-text">Upload a calculated heatmap file to visualize the data.</p>
        
        <div class="chart-container">
            <canvas id="chart"></canvas>
            <div class="axis-label x-positive">Pleasant</div>
            <div class="axis-label x-negative">Unpleasant</div>
            <div class="axis-label y-positive">Active</div>
            <div class="axis-label y-negative">Passive</div>
        </div>

        <div id="message-box"></div>

        <div class="info-panel">
            <input type="file" id="paletteInput" accept=".json" style="display: none;">
            <button class="secondary" onclick="document.getElementById('paletteInput').click()">Upload Palette</button>
            <button class="secondary" onclick="downloadPalette()">Download Palette</button>
            <input type="file" id="heatmapDataInput" accept=".json" style="display: none;">
            <button onclick="document.getElementById('heatmapDataInput').click()">Upload Heatmap Data</button>
        </div>
    </div>

    <script>
        // --- Global state variables ---
        let masterData = {
            fullTerritoryMap: [],
            avgEnergyUsed: 0
        };
        let rankedTerritories = [];

        let colorPalette = {
            zeroColor: "#e5f5ff",
            gradient: [
                {offset: 0, color: "#2c7bb6"}, {offset: 0.125, color: "#00a6ca"},
                {offset: 0.25, color: "#00ccbc"}, {offset: 0.375, color: "#90eb9d"},
                {offset: 0.5, color: "#ffff8c"}, {offset: 0.625, color: "#f9d057"},
                {offset: 0.75, color: "#f29e2e"}, {offset: 0.875, color: "#e76818"},
                {offset: 1, color: "#d7191c"}
            ]
        };
        let colorScale = d3.scaleLinear().domain(colorPalette.gradient.map(s => s.offset)).range(colorPalette.gradient.map(s => s.color));

        const canvas = document.getElementById('chart');
        const ctx = canvas.getContext('2d');
        const heatmapDataInput = document.getElementById('heatmapDataInput');
        const paletteInput = document.getElementById('paletteInput');
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = container.clientWidth - 40;
            canvas.width = size;
            canvas.height = size;
            draw();
        }

        function dataToCanvas(x, y) {
            const canvasX = (x + 120) * canvas.width / 240;
            const canvasY = (120 - y) * canvas.height / 240;
            return {x: canvasX, y: canvasY};
        }
        
        function drawHeatmapLayer() {
            if (masterData.fullTerritoryMap.length === 0) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const minDimension = Math.min(canvas.width, canvas.height);
            const outerRadius = (100 / 120) * (minDimension / 2);
            const innerRadius = (20 / 120) * (minDimension / 2);

            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI, false);
            ctx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI, true);
            ctx.clip();

            // Draw fills for all territories
            masterData.fullTerritoryMap.forEach(territory => {
                if (!territory.polygon) return;

                if (territory.stats) {
                    const rankIndex = rankedTerritories.findIndex(rt => rt.emotion === territory.emotion);
                    if (rankIndex !== -1) {
                        const rank = rankedTerritories.length > 1 ? rankIndex / (rankedTerritories.length - 1) : 1;
                        ctx.fillStyle = colorScale(rank);
                    }
                } else {
                    ctx.fillStyle = colorPalette.zeroColor;
                }
                
                ctx.beginPath();
                territory.polygon.forEach((point, pIndex) => {
                    const pos = dataToCanvas(point.x, point.y);
                    if (pIndex === 0) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                });
                ctx.closePath();
                ctx.fill();
            });

            // Draw borders for ALL territories
            ctx.strokeStyle = '#cccccc'; // Changed to light grey
            ctx.lineWidth = 1;
            masterData.fullTerritoryMap.forEach(territory => {
                if (!territory.polygon) return;
                ctx.beginPath();
                territory.polygon.forEach((point, index) => {
                    const pos = dataToCanvas(point.x, point.y);
                    if (index === 0) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                });
                ctx.closePath();
                ctx.stroke();
            });

            ctx.restore();
        }

        function drawEmotionDots() {
            if (masterData.fullTerritoryMap.length === 0) return;
            masterData.fullTerritoryMap.forEach(territory => {
                const dominanceAvg = territory.stats ? territory.stats.dominanceAvg : 0;
                const pos = dataToCanvas(territory.coordinates.x, territory.coordinates.y);
                const radius = territory.stats ? (6 + (dominanceAvg * 3)) : 2;
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = territory.stats ? '#555555' : '#cccccc';
                ctx.fill();
            });
        }

        function drawEmotionLabels() {
            if (masterData.fullTerritoryMap.length === 0) return;
            masterData.fullTerritoryMap.forEach(territory => {
                const dominanceAvg = territory.stats ? territory.stats.dominanceAvg : 0;
                const radius = territory.stats ? (6 + (dominanceAvg * 3)) : 2;
                const pos = dataToCanvas(territory.coordinates.x, territory.coordinates.y);
                
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                
                const textWidth = ctx.measureText(territory.emotion).width;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(pos.x - textWidth/2 - 2, pos.y - (radius + 14), textWidth + 4, 12);
                
                ctx.fillStyle = '#555';
                ctx.fillText(territory.emotion, pos.x, pos.y - (radius + 2));
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // --- Correct Drawing Order ---

            // 1. Draw Grid
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            for (let radius = 20; radius <= 100; radius += 20) {
                const minDimension = Math.min(canvas.width, canvas.height);
                const canvasRadius = (radius / 120) * (minDimension / 2);
                ctx.beginPath();
                ctx.arc(centerX, centerY, canvasRadius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();

            // 2. Draw Clipped Heatmap Layer (Fills and Borders)
            drawHeatmapLayer();

            // 3. Draw Energy Orb
            if (masterData && masterData.avgEnergyUsed > 0) {
                const maxOrbRadius = 40;
                const orbRadius = (masterData.avgEnergyUsed / 100) * maxOrbRadius;
                ctx.beginPath();
                ctx.arc(centerX, centerY, orbRadius, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.5)';
                ctx.stroke();
                ctx.fillStyle = '#333';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(Math.round(masterData.avgEnergyUsed), centerX, centerY);
            }

            // 4. Draw Emotion Dots
            drawEmotionDots();

            // 5. Draw Emotion Labels (Top Layer)
            drawEmotionLabels();
        }

        let messageTimer;
        function showMessage(text, type = 'error') {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = text;
            messageBox.style.backgroundColor = type === 'error' ? '#ff6b6b' : (type === 'info' ? '#6c757d' : '#4ecdc4');
            messageBox.classList.add('show');
            clearTimeout(messageTimer);
            messageTimer = setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }
        
        // NEW - Refactored function to process data from any source (file upload or URL fetch)
        function processAndDrawHeatmap(data) {
             if (data && data.fullTerritoryMap && typeof data.avgEnergyUsed !== 'undefined') {
                data.fullTerritoryMap.forEach(t => {
                    if (typeof t.polygon === 'string') {
                        try {
                            t.polygon = JSON.parse(t.polygon);
                        } catch(e) {
                             console.error("Failed to parse polygon string for emotion:", t.emotion);
                             t.polygon = null; // Set polygon to null if parsing fails
                        }
                    }
                });
                masterData = data;
                rankedTerritories = masterData.fullTerritoryMap.filter(t => t.stats).sort((a, b) => a.stats.appearances - b.stats.appearances);
                showMessage('Heatmap data loaded successfully!', 'success');
                draw();
            } else {
                showMessage('Invalid or corrupted data structure received.');
            }
        }

        // UPDATED - Now uses the refactored processAndDrawHeatmap function
        function handleHeatmapDataUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const parsedData = JSON.parse(e.target.result);
                    // n8n often wraps results in an array, so we handle that case here
                    const heatmapObject = Array.isArray(parsedData) ? parsedData[0] : parsedData;
                    processAndDrawHeatmap(heatmapObject);
                } catch (error) {
                    showMessage('Failed to parse JSON file.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function downloadPalette() {
            const dataStr = JSON.stringify(colorPalette, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'heatmap_palette.json');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function handlePaletteUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const newPalette = JSON.parse(e.target.result);
                    if (newPalette.zeroColor && Array.isArray(newPalette.gradient) && newPalette.gradient.every(s => typeof s.offset === 'number' && typeof s.color === 'string')) {
                        colorPalette = newPalette;
                        colorScale = d3.scaleLinear().domain(colorPalette.gradient.map(s => s.offset)).range(colorPalette.gradient.map(s => s.color));
                        showMessage('Palette loaded successfully!', 'success');
                        draw();
                    } else {
                        showMessage('Invalid palette file structure.');
                    }
                } catch (error) {
                    showMessage('Failed to parse palette file.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // NEW - Function to load data from URL via webhook
        async function loadDataFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            // FIX 1: Look for 'heatmap_id' in the URL, not 'id'
            const heatmapId = urlParams.get('heatmap_id');

            if (heatmapId) {
                // Use the new webhook URL with "heatmap_plus_id"
                const webhookUrl = `https://n8n.srv968843.hstgr.cloud/webhook-test/heatmap_plus_id?id=${heatmapId}`;
                showMessage('Fetching heatmap data...', 'info');

                try {
                    const response = await fetch(webhookUrl);
                    if (!response.ok) {
                        throw new Error(`Server responded with status: ${response.status}`);
                    }
                    const data = await response.json();
                    processAndDrawHeatmap(data);
                } catch (error) {
                    console.error("Error fetching heatmap data:", error);
                    showMessage(`Error: Could not fetch heatmap data. ${error.message}`, 'error');
                }
            }
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        heatmapDataInput.addEventListener('change', handleHeatmapDataUpload, false);
        paletteInput.addEventListener('change', handlePaletteUpload, false);
        
        document.addEventListener('DOMContentLoaded', (event) => {
            resizeCanvas();
            // NEW - Call the function to check URL for data on page load
            loadDataFromUrl();
        });
    </script>
</body>
</html>


